// The metadata functions for this app

import time from './time.js';
import constants from './constants.js';
import utils from './utils.js';

const metadata = function(){

  // This is the default binning function.  It simply returns the value
  // of the column (that is, it does no meaningful binning).
  //
  function defaultBinner(row, column){
    return row[column];
  }

  // Binning representation.  Provide access to functions that convert data
  // elements (e.g. dates) into binned representations (e.g. by-month).
  //
  const binners = {
    byMonth: {
      internal: time.byMonth, external: time.msecToHumanMonth
    },
    default: {
      internal: defaultBinner, external: null
    },
  };

  // This describes each column.  Tools like Tableau create defaults for
  // metadata, then let the user modify it.
  //
  // '# Records' is a synthetic field.  It represents the summary of the
  //   event (e.g. Air Force Recruits, TAC tickets, etc.).
  //   It must always have type Number.
  //
  // 'dataset' is also a synthetic field:  its 'name' value describes the
  //  name of the dataset.
  //    'months':  vector that describes the months
  //               in which the data reside (currently this is used for 
  //               call center modeling).  May be null.
  //    'model': the name of the model that this dataset uses, if any.
  //
  // The goal is to make dataset-specific changes here, and here only!
  //
  // Metadata definitions:
  //
  // alias
  //   the label used for the column in the app
  // calculated
  //   the field is calculated from another field.  Documentation TBD.
  // datapoint (boolean)
  //   indicates that the values for the column define a single datapoint
  //   (bubble) in the chart
  // dataset
  //   describes the dataset itself.
  // datasetName
  //   The name of the dataset that we should switch to, when selecting
  //   this column.  Used for time series implementation, when the
  //   shape of the data changes radically (that is, not easily transformed
  //   via a pivot).
  // defaultDatapoint (boolean)
  //   indicates that, on initialization, this column is what describes the
  //   datapoint (bubble)
  // defaultXValue, defaultYValue, defaultRadiusValue, defaultColorValue
  //   the value of the (categorical) column that is displayed on the
  //   X (Y, Size) axis, by default.
  //   If this is 'self', then the column itself is displayed.
  // filter
  //   Vector of values that, by default, will be in the initial filter for
  //   this column.  Used in the Refine Results component.
  // format
  //   Transform the value for the field when showing it in a tooltip or
  //   in the facet search.  In addition, if 'useFormat' is true, then
  //   transform this value using the format directly in the data (causing
  //   it to appear formatted in the graphs as well).
  // geoclass
  //   the geographical type of this column, if it represents a map
  //   coordinate
  // geoproperty
  //   the name of the attribute used to join the column with the geo
  //   dataset (e.g. us-states.json)
  // isAverage (boolean)
  //   If true, this specifies a column containing an average Numeric value.
  // noAxis (boolean)
  //   If true, do not allow the user to choose this column for any axis
  //   (x, y, size, or color).
  // noColor (boolean)
  //   If true, do not allow the user to choose this column for color axis.
  // noRadius (boolean)
  //   If true, do not allow the user to choose this column for size axis.
  // obscure (boolean)
  //   If true, do not show the values in tooltips
  // output
  //   The name of the column that is generated by this column.
  //   Currently used to convert DateString columns into Date columns
  //   (which hold the date in millisecons).
  // searchable (boolean)
  //   If true, the user can do a faceted search on the values of this
  //   column
  // summary (boolean)
  //   If true, then this variable appears on the summary table.  Only meaningful
  //   for numeric variables.
  // summaryValues (boolean)
  //   If true, then add categorical value information to the summary.
  // tooltip (boolean)
  //   The number of appearances of any of the values for this column will
  //   appear in the tooltip for the datapoint.
  // type
  //   the type of the column:
  //     'Categorical' indicates a categorical variable.
  //     'Date' indicates a date in milliseconds.
  //     'DateString' indicates a date in string format.  See output.
  //     'Number' indicates a numeric value
  //     'String' indicates a string with no a-priori values
  //       (that is, not a categorical variable)
  // useFormat (boolean)
  //   Transform the data using 'format', effectively changing its value
  //   everywhere.
  // whatIfOriginal
  //   the name of the column that is a copy of another column, presumably
  //   because the other column is being changed due to what if processing.
  //   See whatIfTarget.
  // whatIfTarget
  //   a column whose value is changed, during preprocessing, if a
  //   load table is created and applied.
  //
  const airForceMetadata = {
    dataset: {
      // name: 'FY11Accessions', alias: 'Air Force Recruitment',
      name: 'test1000.csv', alias: 'Air Force Recruitment',
      subtitle: '2005 and later',
      graphtype: 'bubble',         // by default, show the bubble chart
    },
    APPLICLEADORIGIN_CD_DSP: {
      alias: 'Lead Origin', type: 'String', searchable: true
    },
    GAINSTATUS_CD: {
      alias: 'Gain Status', type: 'Categorical', tooltip: true,
      searchable: true, datapoint: true
    },
    GENDER: {
      alias: 'Gender', type: 'Categorical', tooltip: true,
      searchable: true, datapoint: true,
      defaultYValue: 'Male',
    },
    LEADTYPE_CD: {
      alias: 'Lead Type', type: 'Categorical', tooltip: true,
      searchable: true, datapoint: true
    },
    RACE: {
      alias: 'Ethnicity', type: 'String', tooltip: false,
      searchable: true, datapoint: true
    },
    STATE: {
      alias: 'State', type: 'String', searchable: true, datapoint: true,
      geoclass: 'State', geoproperty: 'abbr', defaultDatapoint: true
    },
    GAIN_DT: {
      alias: 'Gain Date', animation: true, type: 'Date', tooltip: false,
      datapointAlias: 'A month of gains',
      binner: 'byMonth', datapoint: true
    },
    CREATE_DT: {
      alias: 'Creation Date', type: 'Date', tooltip: false,
      datapointAlias: 'A month of creation dates',
      binner: 'byMonth', datapoint: true
    },
    '# Records': {
      alias: 'Customers', type: 'Number', tooltip: true
    }
  };

  // Initially we plot:
  //   aggregate by level 2
  //   # tickets on Y, color, and radius
  //   total time to close on X axis
  // 
  const ticketSubjectMetadata = {
    dataset: {
      name: 'TicketWithSubjectTree', alias: 'TAC Ticket', subtitle: 'Oct-Dec 2018',
      graphtype: 'bubble',         // by default, show the bubble chart
    },
    'Ticket #': { // primary key
      alias: 'Ticket #', type: 'String', tooltip: true, obscure: true
    },
    '# Records': { // sum of primary key (tickets)
      alias: '# Tickets', type: 'Number', tooltip: true,
      defaultYValue: 'self', defaultColorValue: 'self',
      defaultRadiusValue: 'self'
    },
    'Subject Level 1': {
      alias: 'Level 1', type: 'Categorical', tooltip: true,
      searchable: true, datapoint: true
    },
    'Subject Level 2': {
      alias: 'Level 2', type: 'Categorical',
      searchable: true, datapoint: true,
      defaultDatapoint: true
    },
    'Subject Level 3': {
      alias: 'Level 3', type: 'Categorical',
      searchable: true, datapoint: true,
    },
    'Incident Type': {
      alias: 'Incident Type', type: 'Categorical', tooltip: true,
      searchable: true, datapoint: true,
      filter: ['Phone']
    },
    'Assigned Account': {
      alias: 'Analyst', type: 'Categorical', datapoint: true, tooltip: true,
      summary: true
    },
    'Incident S/A': {
      alias: 'Service', type: 'Categorical', tooltip: true,
      searchable: true, datapoint: true
    },
    'Date Created': {
      type: 'DateString', output: 'Date Created MS'
    },
    'Date Created MS': {
      alias: 'Date Created', animation: true, type: 'Date',
      tooltip: false,
      datapointAlias: 'A month of created tickets',
      binner: 'byMonth', datapoint: true
    },
    'Date Closed': {
      type: 'DateString', output: 'Date Closed MS'
    },
    'Date Closed MS': {
      alias: 'Date Closed', animation: true, type: 'Date',
      tooltip: false,
      datapointAlias: 'A month of closed tickets',
      binner: 'byMonth', datapoint: true
    },
    'Time to Close (Hours)': {
      alias: 'Ticket Time (Hrs)', type: 'Number', tooltip: true,
      defaultXValue: 'self'
    },
    'TOTAL EDIT TIME': {
      alias: 'Ticket Work Time, Raw, Seconds',
      noAxis: true,
      type: 'Number',
      tooltip: true
    },
  };

  const ticketSubjectMetadataSmall = {...ticketSubjectMetadata,
    dataset: {
      name: 'TicketWithSubjectTreeSmall', alias: 'TAC Ticket Small',
      graphtype: 'bubble',         // by default, show the bubble chart
    }
  };

  const callMetadata = {

    // Note the 'months' field, which contains the time period in which
    // the call metadata was generated.  Also, the 'model' field will
    // cause additional components to be displayed.
    //
    dataset: {
      name: 'CallsWithTickets',
      alias: 'Calls with Tickets', subtitle: 'Oct - Dec 2018',
      graphtype: 'bubble',         // by default, show the bubble chart
      disabled: [ 'animate' ],
      model: 'callCenter',
      months: [ '10/2018', '11/2018', '12/2018'],

      // abandoned calls data.  Rather than shoehorn this data into the
      // CallsWithTickets dataset, and then play filtering tricks, we just
      // obtain the data via offline analysis.
      //
      abandonedCallsRegular: 36177,
      abandonedCallsNW: 4034,
      // Percentage of abandoned calls that balk.  Obtained by analyzing
      // the hazard rate of the abandoned calls
      //
      balkPercent: .15
    },
    'ID': { // primary key
      alias: 'ID', type: 'String', tooltip: true,
    },
    '# Records': { // sum of primary key (calls)
      alias: '# Handled Calls', type: 'Number', tooltip: true,
      summary: true,
      defaultYValue: 'self',
    },
    // 'Date': {
      // alias: 'Call Date'
    // },
    // 'Time': {
      // alias: 'Call Time'
    // },
    // 'Duration': {
      // alias: 'Call Duration'
    // },
    // 'Wait Time': {
      // alias: 'Call Wait Time'
    // },
    'Talk Time': {
      alias: 'Talk Time HH:MM:SS'
    },
    // 'Others Time': {
    // },
    // 'Caller Name': {
    // },
    // 'Caller ID': {
    // },
    // 'Target ID': {
    // },
    'Target Name': {
      alias: 'Analyst',
      type: 'Categorical',
      noAxis: true,
      noWhatIf: true,
      summary: true
    },

    // Artificial columns here (see correlator.js):
    //
    analyst: {
      defaultDatapoint: true,
      alias: 'Call Analyst',
      type: 'Categorical', datapoint: true,
      searchable: true,
      noAxis: true,
      noWhatIf: true
    },
    // callOpenDateTime: {
      // type: 'Date'
    // },
    // callOpenEpoch: {
    // },
    // callTalk: {
    // },
    // answerDateTime: { // this is the time of day that the analyst answers
      // alias: 'Call Answer Time'
    // },
    // callCloseDateTime: {  // this is the time of day the analyst hangs up
      // alias: 'Call Hangup Time'
    // },
    // lastTicketOpenDateTime: {  // this is the time of day the ticket is opened
      // alias: 'Ticket Open Time', type: 'Date'
    // },

    // handleSecs: {
      // alias: 'Calculated Handling Time, Seconds', type: 'Number',
      // noAxis: true,
      // whatIfTarget: 'Load', 
    // },
    // handleMinutes: {  // this includes call time and ticket handling time
      // alias: 'Calculated Handling Time, Minutes', type: 'Number',
      // noAxis: true,
      // whatIfTarget: 'Load'
    // },
    // handleMinutesAvg: {  // this includes call time and ticket handling time
      // alias: 'Calculated Handling Time, Minutes' + constants.avgSuffix,
      // isAverage: true,
      // noAxis: true,
      // type: 'Number',
    // },
    // handleHours: {  // this includes call time and ticket handling time
      // alias: 'Calculated Handling Time, Hours',
      // type: 'Number',
      // whatIfTarget: 'Load'
    // },

    ticketSummary_Role: {
      alias: 'Analyst Role', type: 'Categorical',
      searchable: true, datapoint: true,
      noAxis: true,
      summary: true,
      summaryValues: true,
      tooltip: true,
      filter: ['CTO', 'FIN', 'GEN', 'TECH']
    },
    ticketSummary_rawSecsPerCall: {
      alias: 'Phone/Chat Ticket Handling Time, Raw, Seconds',
      noAxis: true,
      type: 'Number',
      whatIfTarget: 'Load'
    },
    // ticketSummary_rawSecsPerCall_100: {
      // alias: 'Phone/Chat Ticket Handling Time, Unloaded, Raw, Seconds',
      // noAxis: true,
      // type: 'Number',
      // whatIfOriginal: 'ticketSummary_rawSecsPerCall'
    // },
    ticketSummary_secsPerCall: {
      alias: 'Phone/Chat Ticket Handling Time, Seconds',
      noAxis: true,
      type: 'Number',
      whatIfTarget: 'Load'
    },
    ticketSummary_minutesPerCall: {
      alias: 'Phone/Chat Ticket Handling Time, Minutes',
      noAxis: true,
      type: 'Number',
      whatIfTarget: 'Load'
    },
    ticketSummary_hoursPerCall: {
      alias: 'Phone/Chat Ticket Handling Time, Hours',
      noAxis: true,
      // defaultXValue: 'self',
      // defaultRadiusValue: 'self',
      type: 'Number',
      // summary: true,
      // tooltip: true,
      whatIfTarget: 'Load'
    },
    ticketSummary_daysWorkPerCall: {
      alias: 'Days Worked',
      type: 'Number',
      tooltip: true
    },
    ticketSummary_minutesPerCallAvg: {
      alias: 'Phone/Chat Ticket Handling Time, Minutes' + constants.avgSuffix,
      noAxis: true,
      isAverage: true,
      type: 'Number',
      tooltip: true
    },
    ticketSummary_utilization: {  // the same value for a particular analyst, so we need avg...
      alias: 'Phone/Chat Ticket Utilization',
      noAxis: true,
      type: 'Number'
    },
    ticketSummary_utilizationAvg: { // ...here's where we get the avg utilization
      alias: 'Phone/Chat Ticket Utilization' + constants.avgSuffix,
      defaultColorValue: 'self',
      isAverage: true,
      type: 'Number',
      tooltip: true
    },

    // durationMinutes: {  // this is all of the time the traveler uses
      // alias: 'Call Duration in Minutes', type: 'Number',
    // },
    talkMinutes: {  // this just includes time the analyst and traveler talk
      alias: 'Talk Time, Minutes',
      noAxis: true,
      type: 'Number'
    },
    talkMinutesAvg: {  // this just includes time the analyst and traveler talk
      alias: 'Talk Time, Minutes' + constants.avgSuffix,
      isAverage: true,
      noAxis: true,
      type: 'Number',
      tooltip: true,
    },
    talkHours: {  // this just includes time the analyst and traveler talk
      alias: 'Talk Time, Hours',  // changing this causes error??
      tooltip: true,
      type: 'Number', summary: true
    },
    talkSecs: {  // this just includes time the analyst and traveler talk
      alias: 'Talk Time, Seconds',  // changing this causes error??
      noAxis: true,
      type: 'Number'
    },

    waitMinutes: {
      alias: 'Wait Time, Minutes',
      noAxis: true,
      type: 'Number'
    },
    waitHours: {  // this includes call time and ticket handling time
      alias: 'Wait Time, Hours',
      type: 'Number',
      summary: true
    },
    waitMinutesAvg: {  // causes the service to calculate average wait time
      alias: 'Wait Time, Minutes' + constants.avgSuffix,
      isAverage: true,
      noAxis: true,
      type: 'Number'
    },

    // Ticket data here
    //
    'Ticket #': { // primary key
      alias: 'Ticket #', type: 'String', obscure: true
    },
    'Subject Level 1': {
      alias: 'Ticket Level 1', type: 'Categorical',
      searchable: true, datapoint: true,
      noAxis: true
    },
    'Subject Level 2': {
      alias: 'Ticket Level 2', type: 'Categorical',
      searchable: true, datapoint: true,
      noAxis: true
    },
    'Subject Level 3': {
      alias: 'Ticket Level 3', type: 'Categorical',
      searchable: true, datapoint: true,
      noAxis: true,
      noWhatIf: true
    },
    'Incident Type': {
      alias: 'Ticket Incident Type',
    },
    // Let's not do this one, as it triplicates the agent
    // 'Assigned Account': {
      // alias: 'Ticket Analyst',
    // },
    'Incident S/A': {
      alias: 'Ticket Service Organization', type: 'Categorical',
      searchable: true, datapoint: true,
      noAxis: true
    },
    'Date Created': {
      alias: 'Ticket Date Created',
      type: 'DateString', output: 'Date Created MS'
    },

    // New field from simple call/ticket correlator
    //
    'TOTAL EDIT TIME': {
      alias: 'Phone Ticket Work Time, Seconds',
      noAxis: true,
      type: 'Number',
      whatIfTarget: 'Load'
    },
    workHours: {
      alias: 'Phone Ticket Work Time, Hours',
      type: 'Number',
      whatIfTarget: 'Load',
      defaultXValue: 'self',
      defaultRadiusValue: 'self',
      summary: true,
      tooltip: true
    },
    workHours_100: {  // what-if variable original value (at 100%)
      alias: 'Phone Ticket Work Time, Hours, 100%',
      noAxis: true,
      type: 'Number',
      whatIfOriginal: 'workHours'
    },

    // 'Date Created MS': {
      // alias: 'Date Created', animation: true, type: 'Date',
      // tooltip: false,
      // datapointAlias: 'A month of created tickets',
      // binner: 'byMonth', datapoint: true
    // },
    // 'Date Closed': {
      // type: 'DateString', output: 'Date Closed MS'
    // },
    // 'Date Closed MS': {
      // alias: 'Date Closed', animation: true, type: 'Date',
      // tooltip: false,
      // datapointAlias: 'A month of closed tickets',
      // binner: 'byMonth', datapoint: true
    // },
    // 'Time to Close (Hours)': {
      // alias: 'Ticket Time (Hrs)',
    // },
    // ticketOpenEpoch: {
      // type: 'Date',
    // }
  };

  const aisSoloMetadata = {
    dataset: {
      name: 'AIS_solo_metrics', alias: 'AIS Metrics',
      subtitle: 'Metrics with Benchmarks',
      graphtype: 'bubble',         // by default, show the bubble chart
    },

    // This one's complicated.  To avoid lots of metadata if-tests
    // and complexity, we simply switch to a different dataset
    // (which implies a new metadata object).
    //
    xMonth: {
      alias: 'Monthly Activity', type: 'DateString',
      noPareto: true,  // do not allow this choice on Pareto chart
      noAxis: true,
      datapoint: true,
      datasetName: 'AIS_time_series'
    },
    Entity: {
      alias: 'Entity ID', type: 'String',
      noAxis: true,
      datapoint: true
    },
    xName: {
      alias: 'Entity Name', type: 'Categorical',
      searchable: true, datapoint: true,
      noAxis: true
    },
    xStatus: {
      alias: 'Status', type: 'Categorical',
      searchable: true, datapoint: true,
      noAxis: true
    },
    xInvestmentType: {
      alias: 'Investment Type', type: 'Categorical',
      searchable: true, datapoint: true,
      tooltip: true,
      defaultDatapoint: true,
      noAxis: true
    },
    xPhase: {
      alias: 'Phase', type: 'Categorical',
      searchable: true, datapoint: true,
      noAxis: true
    },
    xInceptionDate: {
      alias: 'Inception Date',
      type: 'DateString',
      calculated: {
        idx: 1,
        transform: utils.getInceptionDate,
        fields: ['xFlows', 'Date']
      },
      tooltip: true, tooltipIndex: 0
    },
    // Note the use of an alias that adds a space on the end,
    // for uniqueness relative to xInceptionDate above.
    //
    xInceptionDateMS: {
      alias: 'Inception Date ',
      type: 'Number',
      axisFormat: 'date',
      noYAxis: true, noColor: true, noRadius: true,
      calculated: {
        idx: 2,
        transform: utils.getDateMS,
        fields: ['xInceptionDate']
      }
    },

    xCommitment: {
      alias: 'Commitment', type: 'Number',
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 1
    },
    xPIC: {
      alias: 'Paid In Capital', type: 'Number',
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 2,
      defaultXValue: 'self', defaultColorValue: 'self',
    },
    xCumDistribution: {
      alias: 'Distributions', type: 'Number',
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 3,
      defaultRadiusValue: 'self'
    },
    xNav: {
      alias: 'Net Asset Value', type: 'Number',
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 4,
    },
    xFlows: { alias: 'Cash Flows', type: 'Vector' },
    xDPI: {
      alias: 'DPI', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: { idx: 0, transform: utils.getDPI, fields: ['xCumDistribution', 'xPIC'] },
      tooltip: true, tooltipIndex: 5,
    },
    xRVPI: {
      alias: 'RVPI', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: { idx: 1, transform: utils.getRVPI, fields: ['xNav', 'xPIC'] },
      tooltip: true, tooltipIndex: 6,
    },
    xTVPI: {
      alias: 'TVPI', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: { idx: 2, transform: utils.getTVPI, fields: ['xNav', 'xCumDistribution', 'xPIC'] },
      tooltip: true, tooltipIndex: 7
    },
    xCall: {type: 'Number', noAxis: true},
    xDistribution: {type: 'Number', noAxis: true},
    xDate: {alias: 'Date', type: 'DateString'},

    // Calculate IRR at runtime, so we can get IRR on investment
    // class, not just by entity.
    //
    xIRR: {
      alias: 'IRR', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      defaultYValue: 'self',
      calculated: {
        idx: 3,
        transform: utils.getXIRRfromGroup,
        fields: ['xFlows', 'xCall', 'xDistribution', 'xDate']
      },
      tooltip: true, tooltipIndex: 8
    },

    // Decile is CATEGORICAL: We want to allow filtering.
    //
    xEntityIRRDecile: {
      alias: 'Entity IRR Decile', type: 'Categorical',
      noAxis: true,
      searchable: true,
      datapoint: true
    },

    // Decile is CATEGORICAL: We want to allow filtering.
    //
    xEntityCommitmentDecile: {
      alias: 'Entity Commitment Decile', type: 'Categorical',
      noAxis: true,
      searchable: true,
      datapoint: true
    },

    // Decile is CATEGORICAL: We want to allow filtering.
    //
    xEntityDistributionDecile: {
      alias: 'Entity Distribution Decile', type: 'Categorical',
      noAxis: true,
      searchable: true,
      datapoint: true
    },
    SP500: { alias: 'S&P 500', type: 'Vector' },
    CambridgePE: { alias: 'Cambridge PE', type: 'Vector' },
    CambridgeVC: { alias: 'Cambridge VC', type: 'Vector' },
    PreqinPE: { alias: 'Preqin PE', type: 'Vector' },
    PreqinVC: { alias: 'Preqin VC', type: 'Vector' },
    xIRRvsSPY: {
      alias: 'IRR vs S&P 500', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: {
        idx: 11,
        transform: utils.getDeltaFromBenchmarks,
        fields: ['xIRR', 'SP500', 'vintage', 'medianIRR']
      },
      tooltip: true, tooltipIndex: 20
    },
    xIRRvsCambridgePE: {
      alias: 'IRR vs Cambridge PE', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: {
        idx: 11,
        transform: utils.getDeltaFromBenchmarks,
        fields: ['xIRR', 'CambridgePE', 'vintage', 'medianIRR']
      },
      tooltip: true, tooltipIndex: 21
    },
    xIRRvsCambridgeVC: {
      alias: 'IRR vs Cambridge VC', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: {
        idx: 11,
        transform: utils.getDeltaFromBenchmarks,
        fields: ['xIRR', 'CambridgeVC', 'vintage', 'medianIRR']
      },
      tooltip: true, tooltipIndex: 22
    },
    xIRRvsPreqinPE: {
      alias: 'IRR vs Preqin PE', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: {
        idx: 11,
        transform: utils.getDeltaFromBenchmarks,
        fields: ['xIRR', 'PreqinPE', 'vintage', 'medianIRR']
      },
      tooltip: true, tooltipIndex: 23
    },
    xIRRvsPreqinVC: {
      alias: 'IRR vs Preqin VC', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: {
        idx: 11,
        transform: utils.getDeltaFromBenchmarks,
        fields: ['xIRR', 'PreqinVC', 'vintage', 'medianIRR']
      },
      tooltip: true, tooltipIndex: 24
    },
    '# Records': {
      alias: '# Entities', type: 'Number',
      tooltip: true, tooltipIndex: 100
    }
  };

  // A smaller, independent set of fields for time series plotting.
  //
  // Trying to shoehorn these fields into the above dataset is far too
  // daunting a task, so it seems to make sense to create an entirely
  // separate metadata object for time series.
  //
  // The actual dataset is AIS_solo_metrics;  this dataset is referred
  // to as a "synthetic dataset" as it is a transformation of
  // that original dataset.
  //
  const aisTimeMetadata = {
    dataset: {
      name: 'AIS_time_series', alias: 'AIS Metrics',
      actualName: 'AIS_solo_metrics',
      subtitle: 'Metrics with Benchmarks',
      noShow: true,                   // don't show this in 'Select a dataset'
      yDomainZero: true,              // set the Y axis to always show 0
      noLabel: true,                  // labels are VERY noisy in this plot
      datapointCol: 'xName',          // get the ACTUAL data by Entity Name...
      graphtype: 'line',              // by default, show the line chart
      transform: utils.getTimeSeries, // and transform it to time series...
      
      // FIXME: Consider passing utils.binByMonth, allowing flexibility to
      // bin by other time periods (week/quarter/year).  If we do that, then
      // create a sub-metadata object and share it among the various time series
      // metadata objects to define numeric fields.
      //
      transformFields: ['xName', '# Records', 'xFlows', 'Date', 'xMonth', 'xMonthMS']
    },
    xMonth: {
      alias: 'Monthly Activity', type: 'DateString',
      noPareto: true,  // do not allow this choice on Pareto chart
      noAxis: true,
      datapoint: true,
      defaultDatapoint: true
    },
    xMonthMS: {
      alias: 'Month', type: 'Number',
      defaultXValue: 'self',
      axisFormat: 'date',
      noYAxis: true, noColor: true, noRadius: true,
    },
    xFlows: { alias: 'Cash Flows', type: 'Vector' },
    'Date': { alias: 'Date', type: 'DateString' },

    // This is how we switch back to the original metadata object.
    //
    Entity: {
      alias: 'Entity ID', type: 'String',
      noAxis: true,
      datapoint: true,
      datasetName: 'AIS_solo_metrics'
    },
    xName: {
      alias: 'Entity Name', type: 'Categorical',
      searchable: true, datapoint: true,
      noAxis: true,
      datasetName: 'AIS_solo_metrics'
    },

    // Numeric fields, to be binned by month
    //
    xCall: {
      alias: 'Paid In Capital',
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 1.0,
      type: 'Number'
    },
    xCumCall: {
      alias: 'Paid In Capital, Cumulative', type: 'Number',
      calculated: {
        idx: 2,
        transform: utils.getCumulative,
        fields: ['xCall', 'xCumCall']
      },
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 1.1,
    },

    xDistribution: {
      alias: 'Distributions',
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 2.0,
      type: 'Number'
    },
    xCumDistribution: {
      alias: 'Distributions, Cumulative', type: 'Number',
      calculated: {
        idx: 2,
        transform: utils.getCumulative,
        fields: ['xDistribution', 'xCumDistribution']
      },
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 2.1,
    },

    xCashFlow: {
      alias: 'Net Cash Flow', type: 'Number',
      calculated: {
        idx: 1,
        transform: utils.getCashFlow,
        fields: ['xCall', 'xDistribution']
      },
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 3.0,
    },

    xCumCashFlow: {
      alias: "Net Cash Flow, Cumulative", type: 'Number',
      calculated: {
        idx: 2,
        transform: utils.getCumulative,
        fields: ['xCashFlow', 'xCumCashFlow']
      },
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 3.1,
    },

    xNav: {
      alias: 'Net Asset Value',
      defaultRadiusValue: 'self',
      defaultColorValue: 'self',
      format: 'thousand', axisFormat: 'million',
      type: 'Number',
      // This means that the element should not be summed by cash flow
      // event: instead, a single entity's NAV is the same for a single
      // time period (actually, it only varies by quarter).
      // See utils.preProcessData().
      //
      subtype: 'byPeriodEntity',
      tooltip: true, tooltipIndex: 4.0,
    },
    xNavPlusCash: {
      alias: 'NAV Plus Net Cash', type: 'Number',
      calculated: {
        idx: 3,
        transform: utils.add,
        fields: ['xCumCashFlow', 'xNav']
      },
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 4.1,
    },

    xTotalValue: {
      alias: 'Total Value (NAV Plus Dist)', type: 'Number',
      defaultYValue: 'self',
      calculated: {
        idx: 3,
        transform: utils.add,
        fields: ['xCumDistribution', 'xNav']
      },
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 5.0,
    },

    xDPI: {
      alias: 'DPI', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: {
        idx: 3,
        transform: utils.getDPI,
        fields: ['xCumDistribution', 'xCumCall']
      },
      tooltip: true, tooltipIndex: 6.0,
    },
    xRVPI: {
      alias: 'RVPI', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: {
        idx: 3,
        transform: utils.getRVPI,
        fields: ['xNav', 'xCumCall']
      },
      tooltip: true, tooltipIndex: 6.1,
    },
    xTVPI: {
      alias: 'TVPI', type: 'Number',
      format: 'percent', axisFormat: 'percent',
      calculated: {
        idx: 3,
        transform: utils.getTVPI,
        fields: ['xNav', 'xCumDistribution', 'xCumCall']
      },
      tooltip: true, tooltipIndex: 6.2 
    },

    // S&P 500 benchmark comparison values.
    //
    xSPYshares: {
      alias: 'S&P 500 Shares',
      type: 'Number',
      noAxis: true,
    },
    xSPYprice: {
      alias: 'S&P 500 Price per Share',
      type: 'Number',
      // This means that the element should not be summed by cash flow
      // event: instead, every entity's SPY price is the same for a 
      // single time period (across all entities).
      //
      subtype: 'byPeriod',
      format: 'thousand', axisFormat: 'dollar',
      tooltip: true, tooltipIndex: 7.0
    },
    xSPYdividend: {
      alias: 'S&P 500 Dividend',
      type: 'Number',
      format: 'thousand', axisFormat: 'dollar',
      tooltip: true, tooltipIndex: 7.1
    },
    xCumSPYShares: {
      alias: "S&P 500 Cum Shares", type: 'Number',
      noAxis: true,
      calculated: {
        idx: 2,
        transform: utils.getCumulative,
        fields: ['xSPYshares', 'xCumSPYShares']
      },
      tooltip: true, tooltipIndex: 7.2,
    },
    xCumSPYDividends: {
      alias: "S&P 500 Dividend, Cumulative", type: 'Number',
      format: 'thousand', axisFormat: 'dollar',
      calculated: {
        idx: 2,
        transform: utils.getCumulative,
        fields: ['xSPYdividend', 'xCumSPYDividends']
      },
      tooltip: true, tooltipIndex: 7.3,
    },
    // The following is equivalent to Total Value, but for S&P 500.
    // We add the share price appreciation to the sum of all
    // dividends.
    //
    xSPYValue: {
      alias: 'S&P 500 Value', type: 'Number',
      calculated: {
        idx: 3,
        // transform: utils.multiply,
        // fields: ['xCumSPYShares', 'xSPYprice']
        transform: utils.getTotalValue,
        fields: ['xCumSPYShares', 'xSPYprice', 'xCumSPYDividends']
      },
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 7.4
    },
    xTVvsSPY: {  // Total Value minus SPY
      alias: 'Total Value vs S&P 500 Value', type: 'Number',
      calculated: {
        idx: 4,
        transform: utils.subtract,
        fields: ['xTotalValue', 'xSPYValue']
      },
      format: 'thousand', axisFormat: 'million',
      tooltip: true, tooltipIndex: 7.5,
    },

    xLastNavDate: {
      alias: 'Last NAV Date', type: 'DateString',
    },

    // alias MUST BE IDENTICAL to alias in the original dataset,
    // otherwise Refine Results doesn't report the right # of
    // records for searchable columns.
    //
    '# Records': {
      alias: '# Entities', type: 'Number',
      tooltip: true, tooltipIndex: 100
    },

    // Switch back to the prior metadata element
    //
    xInvestmentType: {
      alias: 'Investment Type', noAxis: true, searchable: true,
      datapoint: true,
      datasetName: 'AIS_solo_metrics',
    },
    xPhase: {
      alias: 'Phase', noAxis: true, searchable: true,
      datapoint: true,
      datasetName: 'AIS_solo_metrics',
    },
    xStatus: {
      alias: 'Status', noAxis: true, searchable: true,
      datapoint: true,
      datasetName: 'AIS_solo_metrics',
    },

    xEntityIRRDecile: {
      alias: 'Entity IRR Decile', type: 'Categorical',
      noAxis: true,
      // searchable: true,
      datapoint: true,
      datasetName: 'AIS_solo_metrics',
    },
    xEntityCommitmentDecile: {
      alias: 'Entity Commitment Decile', type: 'Categorical',
      noAxis: true,
      // searchable: true,
      datapoint: true,
      datasetName: 'AIS_solo_metrics'
    },
    xEntityDistributionDecile: {
      alias: 'Entity Distribution Decile', type: 'Categorical',
      noAxis: true,
      // searchable: true,
      datapoint: true,
      datasetName: 'AIS_solo_metrics'
    },
  };

  const custToMeta = {
    ais: aisSoloMetadata,
    mannis: aisSoloMetadata,
    // master: ticketSubjectMetadata,
    // master: aisSoloMetadata,
    master: airForceMetadata,
    dtmo: ticketSubjectMetadata,
    orig: airForceMetadata
  };

  // Get the initial dataset from the environment
  //
  const customer = process.env.CUSTOMER  || 'master';
  const initMetadata = custToMeta[customer];

  const allMetadata = [
    airForceMetadata,
    ticketSubjectMetadata,
    ticketSubjectMetadataSmall,
    callMetadata,
    aisSoloMetadata,
    aisTimeMetadata
  ];

  // We now allow this to change, supporting change dataset.
  // FIXME: Avoid mutation.
  //
  var thisMetadata = initMetadata;

  // Change current metadata.
  // FIXME: Avoid mutation.
  //
  const setMetadata = function(dataset) {
    thisMetadata = getMetadata(dataset);
  }

  const getMetadata = function(dataset) {
    return allMetadata.find(i => {
      return i.dataset.name === dataset;
    });
  }

  const metadataExists = function(dataset) {
    return !!getMetadata(dataset);
  }

  const getInitDataset = function(){
    return initMetadata.dataset.name;
  }

  const getDataset = function(){
    return thisMetadata.dataset.name;
  }

  const getActualDataset = function(){
    return thisMetadata.dataset.actualName || thisMetadata.dataset.name;
  }

  // Return list of datasets in (name, alias) array
  //
  const getAllDatasets = function(){
    return allMetadata.map(i => {
      const show = !i.dataset.noShow;
      return {name: i.dataset.name, alias: i.dataset.alias, show};
    });
  }

  const getDatasetAttr = function(attr){
    return thisMetadata.dataset.hasOwnProperty(attr) ? thisMetadata.dataset[attr] : null;
  }

  const getDatasetLabel = function(){
    return thisMetadata.dataset.alias;
  }

  const getDatasetSubtitle = function(){
    return thisMetadata.dataset.subtitle;
  }

  const getDatasetMonths = function(){
    return thisMetadata.dataset.months;
  }

  const getDatasetModel = function(){
    return thisMetadata.dataset.model;
  }

  // Return vector of disabled controls from the 'dataset' metadata attribute
  //
  const getDatasetDisabled = function() {
    return thisMetadata.dataset.disabled || [];
  }


  // Return an array of column names such that the metadata attribute for the
  // column 'attr' exists.
  //
  const getColumnsWithAttr = function(attr){
    return Object.keys(thisMetadata).filter(function(column){
      return thisMetadata[column].hasOwnProperty(attr);
    });
  }

  // Return all columns that have 'attr' set to a truthy value
  //
  const getColumnsWithAttrTrue = function(attr){
    return Object.keys(thisMetadata).filter(function(column){
      return thisMetadata[column].hasOwnProperty(attr) && thisMetadata[column][attr];
    });
  }

  // Return TRUE if 'column' has attribute 'attr' with the given 'value'
  //
  const hasValue = function(column, attr, value){
    return thisMetadata.hasOwnProperty(column) &&
        thisMetadata[column].hasOwnProperty(attr) &&
        thisMetadata[column][attr]===value;
  }

  const isTrue = function(column, attr) {
    return thisMetadata.hasOwnProperty(column) &&
        thisMetadata[column].hasOwnProperty(attr) &&
        thisMetadata[column][attr];
  }

  // Similar to the above, but only return columns whose attribute matches
  // 'value'.
  //
  const getColumnsByAttrValue = function(attr, value){
    return Object.keys(thisMetadata).filter(function(column){
      return hasValue(column, attr, value);
    });
  }

  // Return 'true' if the given column has attribute===value
  //
  const hasAttributeValue = function(col, attr, value){
    return ( col in thisMetadata && attr in thisMetadata[col] &&
        thisMetadata[col][attr]===value );
  }

  // Return value for 'attr' for given property,
  // or defaultValue if none; if no defaultValue, return ''.
  //
  const getAttrValue = function(col, attr, defaultValue){
    const dValue = defaultValue || '';
    return ( col in thisMetadata && attr in thisMetadata[col] ) ?
        thisMetadata[col][attr] : dValue;
  }

  // Apply 'format' to the value
  //
  const getFormattedValue = function(col, value) {
    if (value === null || value === undefined) {
      return value;
    } else {
      const format = getAttrValue(col, 'format');
      const type = getAttrValue(col, 'type');

      return applyFormat(value, format, type);
    }
  }

  function applyFormat(value, format, type) {
    switch(format) {
      case 'percent':
      {
        const v1 = isFloat(value) ? value * 100 : value;
        const v2 = usePrecision(v1, type) ? v1.toFixed(2) : v1;
        return v2 === null ? '(not available)' : `${v2} %`;
      }
      case 'decile':
      {
        if (isFloat(value)) {
          const outVal = parseFloat(value);
          switch (outVal % 10) {
            case 1: return `${outVal}st Decile`;
            case 2: return `${outVal}nd Decile`;
            case 3: return `${outVal}rd Decile`;
            default: return `${outVal}th Decile`;
          }
        } else {
          return value;
        }
      }
      case 'thousand':
      {
        const v1 = isFloat(value) ? value.toFixed(2) : value;
        const v2 = v1 === null ? '' : v1.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        return `$ ${v2}`;
      }
      case 'title':
      {
        return ((typeof value) !== 'string') ? value : getTitle(value);
      }
      case 'stars':
      {
        return ((typeof value) !== 'string') ? value : getStars(value);
      }
      case 'title-stars':
      {
        return ((typeof value) !== 'string')
          ? value
          : getStars(getTitle(value));
      }
      case 'iso-date':  // convert date into MM/DD/YYYY
      {
        return time.isoToDate(value);
      }
      default:
      {
        return usePrecision(value, type) ? parseFloat(value).toFixed(2) : value;
      }
    }
  }

  // A first approximation of title case.
  // Not great for Scotch names, nor for 'and' in a diagnosis code, etc.
  //
  function getTitle(value) {
    return value === '(Select All)'
      ? value
      : value.toLowerCase().split(' ').map(i => {
          return i.charAt(0).toUpperCase() + i.slice(1);
        }).join(' ');
  }

  // Special formatting for starred diagnosis codes, which are sensitive.
  //
  function getStars(value) {
    return value === '****' ? 'Sensitive Code' : value;
  }

  function usePrecision(value, type) {
    return type==='Number' && isFloat(value) &&
        !Number.isInteger(parseFloat(value));
  }

  function isFloat(value) {
    return !isNaN(parseFloat(value));
  }

  // Return the list of numeric columns
  //
  const getNumerics = function(){
    return getColsWithType('Number');
  }

  const getDates = function(){
    return getColsWithType('Date').concat(getColsWithType('DateString'));
  }

  // Same as the above, but only return the numeric fields that
  // are not calculated fields
  //
  const getNumericsNotCalculated = function() {
    return thisMetadata
      ? Object.keys(thisMetadata)
        .map(i => { return {column: i, ...thisMetadata[i]}; })
        .filter(i => i.type==="Number" && !i.calculated)
        .map(i => i.column)
      : [];
  }

  const getVectors = function(){
    return getColsWithType('Vector');
  }

  // Same as above, but filter out columns that have 'isAverage' set to true.
  //
  const getNonAverageNumerics = function(){
    return thisMetadata
      ? Object.keys(thisMetadata)
        .map(i => { return {column: i, ...thisMetadata[i]}; })
        .filter(i => i.type==="Number" && !i.isAverage)
        .map(i => i.column)
      : [];
  }

  // Return all columns with the given 'type'
  //
  const getColsWithType = function(type) {
    return thisMetadata
      ? Object.keys(thisMetadata)
        .map(i => { return {column: i, ...thisMetadata[i]}; })
        .filter(i => i.type===type)
        .map(i => i.column)
      : [];
  }

  // Return 'alias' if we can't find it
  //
  function aliasToColumn(alias){
    return Object.keys(thisMetadata)
      .filter(i => thisMetadata[i].alias===alias)
      .reduce((v1, v2) => v2, alias);
  }

  // Return the input value to tickFormat, given the alias name.
  //
  function getAxisFormat(alias){
    const col = thisMetadata[aliasToColumn(alias)];
    const axisFormat = col && col.axisFormat || null;
    if (axisFormat === 'million') {
      return function(d) {
        const withCommas = d.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        return Math.abs(d) < 1000000 ? '$' + withCommas : '$' + (d/1000000) + 'M';
      }
    } else if (axisFormat === 'dollar') {
      return function(d) {
        const withCommas = d.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        return '$' + withCommas;
      }
    } else if (axisFormat === 'percent') {
      return d => getPercent(d) + '%';
    } else if (axisFormat === 'date') {
      return d => utils.getMonthFromDateString(d);
    }
    try {
      switch( col.type ){
        case 'Date':  return time.msecToHuman;
        default:      return null;
      }
    } catch(e) {
      return null;
    }
  }

  function getPercent(d) {
    return d > 0.1 ? Math.round(d*100) : Math.round(d*1000)/10;
  }

  // Return alias for 'column'
  //
  function getAlias(column){
    if( column in thisMetadata && 'alias' in thisMetadata[column] ){
      return thisMetadata[column].alias;
    } else {
      return column;
    }
  }

  // Return datapoint representation alias for 'column'
  //
  function getDatapointAlias(column){
    if( column in thisMetadata && 'datapointAlias' in thisMetadata[column] ){
      return thisMetadata[column].datapointAlias;
    } else {
      return getAlias(column);
    }
  }

  // Return list of columns that have attribute .type equal to 'type'
  //
  function getColumnsWithType(type){
    return getColumnsByAttrValue('type', type);
  }

  // Return the array representing all enumerable types.
  // We can use these as pivot fields.
  //
  function getCategoricals(){
    return getColumnsWithType('Categorical');
  }

  // This is like getCategoricals(), but it returns all String columns
  //
  function getStrings(){
    return getColumnsWithType('String');
  }

  // Return all columns that are marked searchable
  //
  function getSearchable(){
    return Object.keys(thisMetadata).filter(function(column){
      return thisMetadata[column].searchable;
    });
  }

  // Return filters in the form
  //   { column: [filter-vector], ... }
  //
  function getFilters(){
    return Object.keys(thisMetadata).filter(i => {
      return thisMetadata[i].hasOwnProperty('filter');
    }).reduce((i, j) => {
      return {...i, ...{[j]: thisMetadata[j].filter}};
    }, {});
  }

  // Given an array of data, transform all IsoDate variables
  // into the equivalent milliseconds-since-epoch.
  //
  // The data's fields are all aliases, not columns.
  //
  function transformIsoDates(data) {
    const applyFn = function(alias, value) {
      return new Date(value);
    }
    return applyIsoDateTransform(data, applyFn);
  }

  // Like the above, but transform all IsoDate variables into
  // their human readable formats.
  //
  // The data's fields are all aliases, not columns.
  //
  function formatIsoDates(data) {
    return applyIsoDateTransform(data, getFormattedValue);
  }

  function applyIsoDateTransform(data, apply) {
    const dateCols = getColsWithType('IsoDate');
    const dateAliasMap = dateCols.reduce((i, j) => {
      return {...i, ...{[j]: getAlias(j)}};
    }, {});
    return data.map(i => {
      const dates = Object.keys(dateAliasMap).reduce((j, k) => {
        const alias = dateAliasMap[k];
        const value = i.hasOwnProperty(alias) ? i[alias] : null;
        const newValue = apply(k, value);
        return {...j, ...{[alias]: newValue}};
      }, {});
      return {...i, ...dates};
    });
  }

  // Return the binner for column.  Return null if there isn't one.
  //
  // This just returns a symbolic name.  Call getBinnerObject() to
  // get the interpreter of the symbolic name.
  //
  function getBinner(column){
    return thisMetadata.hasOwnProperty(column) && thisMetadata[column].binner || null;
  }

  // Similar to getBinner(), but this one returns the internal and
  // external function interpretations of the binner.
  //
  function getBinnerObject(column){
    switch( getBinner(column) ){
      case 'byMonth': return binners.byMonth;
      default:        return binners.default;
    }
  }

  // Convert categoricalValues into a list of the form
  // (col, label), where "label" is a combination of
  // the column's alias and one of the column's categorical values.
  //
  // If filterAttr is present, it represents the name of a metadata
  // attribute that, when present, filters out that particular column.
  //
  function getCategoricalList(categoricalValues, filterAttr) {
    const filterMap = filterAttr ? 
        getColumnsWithAttrTrue(filterAttr).reduce((i, j) => {
      return {...i, ...{[j]: true}};
    }, {}) : {};

    const filterFn = function(i) {
      return !filterMap.hasOwnProperty(i);
    }

    return getCategoricalListFromFilter(categoricalValues, filterFn);
  }

  // Similar to the above, but in this case we pass in the filter function,
  // to make retrieving the categorical list more general.
  //
  function getCategoricalListFromFilter(categoricalValues, filterFn) {
    return [].concat.apply([],
      Object.keys(categoricalValues)
        .filter(filterFn)
        .map(i => {
          const colAlias = getAlias(i);
          return categoricalValues[i].map(j => {
            return {
              col: i, alias: colAlias + ':' + j
            };
          });
        })
      ).sort(utils.sorter('alias'));
  }

  // Return TRUE if 'column' has the given 'geotype'
  //
  const isGeoType = function(column, geotype){
    return hasAttributeValue(column, 'geoclass', geotype);
  }

  // Return list of column names having a valid geoclass
  //
  const getGeoCols = function(){
    return getColumnsWithAttr('geoclass');
  }

  // Return the geo property for the given column, or "" if none
  //
  const getGeoProperty = function(column){
    return getAttrValue(column, 'geoproperty');
  }

  // Given a metadata 'attr', return reverse map of the form:
  //   { ATTR-VALUE: [ COL-NAME, ... ], ... }
  // Used for, e.g., whatIfTarget to get the list of targets for a 
  // particular load percentage.
  //
  const getReverseMap = function(attr) {
    return Object.keys(thisMetadata).filter(i => {
      return thisMetadata[i].hasOwnProperty(attr);
    }).reduce((i, j) => {
      const attrValue = thisMetadata[j][attr];
      const prevArray = i[attrValue] ? i[attrValue] : [];
      const newArray = prevArray.concat([j]);
      return {...i, ...{[attrValue]: newArray}};
      }, {});
  }

  // Return metadata.getReverseMap, but convert all of the column names
  // to alias names.
  //
  const getAliasedReverseMap = function(attr) {
    const reverseMap = getReverseMap(attr);

    return Object.keys(reverseMap).reduce((i, j) => {
      const alias = getAlias(j);
      const values = reverseMap[j].map(k => {
        return getAlias(k);
      });

      return {...i, ...{[alias]: values}};
    }, {});
  }

  // Return every column name.  Note that 'dataset' is a special column that
  // is not returned by this.
  //
  const getAll = function(){
    return Object.keys(thisMetadata).filter(i => {
      return i !== 'dataset';
    });
  }

  return {
    getInitDataset,
    getDataset,
    getActualDataset,
    getAllDatasets,
    getDatasetAttr,
    getDatasetLabel,
    getDatasetSubtitle,
    getDatasetMonths,
    getDatasetModel,
    getDatasetDisabled,
    getColumnsWithAttrTrue,
    getColumnsByAttrValue,
    getColumnsWithAttr,
    getAttrValue,
    getFormattedValue,
    applyFormat,
    hasValue,
    isTrue,
    hasAttributeValue,
    getDates,
    getNumerics,
    getNumericsNotCalculated,
    getVectors,
    getNonAverageNumerics,
    getColsWithType,
    aliasToColumn,
    getAxisFormat,
    getAlias,
    getDatapointAlias,
    getCategoricals,
    getStrings,
    getSearchable,
    getFilters,
    transformIsoDates,
    formatIsoDates,
    getBinner,
    getBinnerObject,
    getCategoricalList,
    getCategoricalListFromFilter,
    isGeoType,
    getGeoCols,
    getGeoProperty,
    getAll,
    getReverseMap,
    getAliasedReverseMap,
    metadataExists,
    setMetadata
  }
}();

export default metadata;
